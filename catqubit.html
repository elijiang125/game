<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Quantum Cat Qubit | Risograph Stability Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body { margin: 0; background-color: #FAFAFA; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        .interface {
            position: fixed;
            top: 40px;
            left: 40px;
            pointer-events: none;
            z-index: 10;
        }
        .label { font-size: 10px; letter-spacing: 0.3em; color: #005CB9; text-transform: uppercase; margin-bottom: 5px; }
        .stability-wrapper { width: 240px; height: 3px; background: rgba(0, 92, 185, 0.1); }
        #bar { width: 100%; height: 100%; background: #005CB9; transition: width 0.2s; }
        .controls { margin-top: 16px; font-size: 16px; color: #FF665E; font-weight: 400; }
    </style>
</head>
<body>
    <div class="interface">
        <div class="label">Quantum Coherence Stability</div>
        <div class="stability-wrapper"><div id="bar"></div></div>
        <div class="controls">ARROWS: BALANCE ROTATION<br><span id="status">STATE: COHERENT</span></div>
    </div>

    <script>
        // --- 1. Game & Physics State ---
        let angle = 0;
        let rotSpeed = 0.02;
        let stability = 100;
        let isCollapsed = false;

        // --- 2. Risograph Visual Elements ---
        const baseSize = 180;
        const splitDistance = 200;
        let blueFringePts = [];
        let orangeFringePts = [];
        let blobPts = [];
        let noisePts = [];
        let noiseOffset = 0;
        let risoBlue, risoOrange;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            
            risoBlue = color('#005CB9');
            risoOrange = color('#FF665E');

            // 리소그래프 잉크 입자 생성 (최적화를 위해 개수 조절)
            for (let i = 0; i < 12000; i++) {
                blueFringePts.push({ x: randomGaussian(0, 140), y: randomGaussian(0, 60), size: random(1, 3), prob: Math.random() });
                orangeFringePts.push({ x: randomGaussian(0, 140), y: randomGaussian(0, 60), size: random(1, 3), prob: Math.random() });
            }
            for (let i = 0; i < 35000; i++) {
                blobPts.push({ x: randomGaussian(0, baseSize / 2.3), y: randomGaussian(0, baseSize / 2.3), size: random(1.2, 3.5), prob: Math.random() });
            }
            // 종이 질감 입자
            for (let i = 0; i < 15000; i++) {
                noisePts.push({ x: random(width), y: random(height), size: random(1, 1.5) });
            }
        }

        function draw() {
            if (isCollapsed) {
                drawCollapseScreen();
                return;
            }

            background('#FDFDFD');
            drawPaperNoise();

            // --- Physics & Control Update ---
            handleInput();
            updateStability();

            // --- Animation Mapping ---
            // t(0~1)를 현재 angle(0~TWO_PI)에 매핑하여 상태 전이를 구현
            let t = (angle % TWO_PI) / TWO_PI;
            if (t < 0) t += 1.0;

            let squeezeAmt = 0;
            let splitAmt = 0;

            // 상태 시퀀스 (angle에 따라 형태가 바뀜)
            if (t < 0.2) { // Coherent
                squeezeAmt = map(t, 0, 0.2, 0, 1);
            } else if (t < 0.5) { // Squeezing -> Split
                squeezeAmt = 1.0;
                splitAmt = map(t, 0.2, 0.5, 0, 1);
            } else if (t < 0.8) { // Holding Cat State -> Recombine
                squeezeAmt = 1.0;
                splitAmt = map(t, 0.5, 0.8, 1, 0);
            } else { // Return to Round
                squeezeAmt = map(t, 0.8, 1.0, 1, 0);
                splitAmt = 0;
            }

            // --- Rendering ---
            blendMode(MULTIPLY);
            push();
            translate(width / 2, height / 2);
            rotate(angle * 0.2); // 시각적인 재미를 위한 느린 전체 회전

            let shapeSqueeze = squeezeAmt * (1.0 - splitAmt * 0.4);
            let scaleX = lerp(1.0, 0.3, shapeSqueeze);
            let scaleY = lerp(1.0, 2.5, shapeSqueeze);
            let offset = splitDistance * splitAmt;

            // 1. Interference Fringes (Cat state vibration)
            if (splitAmt > 0.1) {
                drawFringes(splitAmt);
            }

            // 2. Main Quantum Blobs
            let flicker = noise(frameCount * 0.1) * 0.2 + 0.9;
            let density = lerp(1.3, 0.8, abs(rotSpeed) * 5); // 속도가 빠를수록 입자가 희박해짐 (불안정 연출)

            if (offset < 2) {
                drawRisoBlob(0, 0, scaleX, scaleY, density * flicker, risoBlue);
            } else {
                drawRisoBlob(0, -offset, scaleX, scaleY, density * flicker, risoBlue);
                drawRisoBlob(0, offset, scaleX, scaleY, density * flicker, risoBlue);
            }
            pop();
            blendMode(BLEND);

            updateUI(squeezeAmt, splitAmt);
        }

        function drawRisoBlob(cx, cy, sx, sy, densityMult, col) {
            fill(col);
            noStroke();
            for (let pt of blobPts) {
                let dSq = pow(pt.x / (baseSize/2.3), 2) + pow(pt.y / (baseSize/2.3), 2);
                let rawProb = exp(-dSq * 4.0);
                if (rawProb * densityMult > pt.prob) {
                    circle(cx + pt.x * sx, cy + pt.y * sy, pt.size);
                }
            }
        }

        function drawFringes(amt) {
            let k = 0.25;
            let phase = frameCount * -0.2;
            
            // Blue Fringes
            fill(risoBlue);
            for (let pt of blueFringePts) {
                let env = exp(-(pt.x*pt.x)/(2*120*120) - (pt.y*pt.y)/(2*40*40));
                let wave = 0.5 + 0.5 * cos(pt.y * k + phase);
                if (env * wave * amt * 1.5 > pt.prob) circle(pt.x, pt.y, pt.size);
            }
            // Orange Fringes
            fill(risoOrange);
            for (let pt of orangeFringePts) {
                let env = exp(-(pt.x*pt.x)/(2*120*120) - (pt.y*pt.y)/(2*40*40));
                let wave = 0.5 + 0.5 * cos(pt.y * k + PI + phase);
                if (env * wave * amt * 1.8 > pt.prob) circle(pt.x, pt.y, pt.size);
            }
        }

        function handleInput() {
            if (keyIsDown(LEFT_ARROW)) rotSpeed -= 0.004;
            if (keyIsDown(RIGHT_ARROW)) rotSpeed += 0.004;
            
            rotSpeed += (noise(frameCount * 0.05) - 0.5) * 0.002; // 양자 요동(Fluctuation)
            rotSpeed *= 0.985; // 마찰력
            angle += rotSpeed;
        }

        function updateStability() {
            let absSpeed = abs(rotSpeed);
            if (absSpeed > 0.1) { // 임계 속도 초과 시 안정성 하락
                stability -= 0.6;
            } else {
                stability = min(100, stability + 0.1);
            }

            document.getElementById('bar').style.width = stability + "%";
            if (stability <= 0) isCollapsed = true;
        }

        function updateUI(squeeze, split) {
            let status = "STATE: COHERENT";
            if (split > 0.5) status = "STATE: CAT (SUPERPOSITION)";
            else if (squeeze > 0.5) status = "STATE: SQUEEZED";
            document.getElementById('status').innerText = status;
        }

        function drawPaperNoise() {
            fill(0, 0, 0, 12);
            noStroke();
            for (let pt of noisePts) {
                rect(pt.x, pt.y, pt.size, pt.size);
            }
        }

        function drawCollapseMsg() {
            blendMode(BLEND);
            fill(risoOrange);
            textAlign(CENTER);
            textSize(40);
            text("STATE COLLAPSED", width/2, height/2);
            textSize(15);
            fill(0, 100);
            text("System Decoherece due to High Velocity. Press F5.", width/2, height/2 + 40);
        }

        function drawCollapseScreen() {
            background('#FDFDFD');
            drawPaperNoise();
            drawCollapseMsg();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>