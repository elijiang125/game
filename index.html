<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Quantum State Transition - Risograph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #FAFAFA;
            overflow: hidden;
            font-family: sans-serif;
        }

        canvas {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            background-color: #FDFDFD;
        }
    </style>
</head>

<body>
    <script>
        const totalFrames = 180; // Faster loop! 3 seconds total at 60fps (180 frames)
        const baseSize = 200;
        const splitDistance = 220;

        // Arrays for generating stippled ink clouds
        let blueFringePts = [];
        let orangeFringePts = [];
        let blobPts = [];

        // We will use 1D noise for the subtle "flicker" effect
        let noiseOffset = 0;

        let risoBlue, risoOrange;

        function setup() {
            createCanvas(900, 600);
            pixelDensity(1);

            // Classic Risograph ink colors
            risoBlue = color('#005CB9');
            risoOrange = color('#FF665E');

            // Fringes (gathered horizontally X, spread vertically Y between the split)
            for (let i = 0; i < 20000; i++) {
                blueFringePts.push({
                    x: randomGaussian(0, 50), // Gathered very tight in center X
                    y: randomGaussian(0, 140), // Spread across Y
                    size: random(1, 4),
                    prob: Math.random()
                });
                orangeFringePts.push({
                    x: randomGaussian(0, 50),
                    y: randomGaussian(0, 140),
                    size: random(1, 4),
                    prob: Math.random() // independent probability
                });
            }

            // Points for the main quantum state blobs
            // Massive cloud with very tight cohesive bounds
            for (let i = 0; i < 60000; i++) {
                blobPts.push({
                    x: randomGaussian(0, baseSize / 2.2),
                    y: randomGaussian(0, baseSize / 2.2),
                    size: random(1.5, 4.5),
                    prob: Math.random()
                });
            }
        }

        // Smooth transition easing
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function drawRisoBlob(cx, cy, scaleX, scaleY, densityMultiplier, col) {
            fill(col);
            noStroke();

            let flickerBase = noise(noiseOffset) * 0.4 + 0.6; // Subtle flicker

            for (let pt of blobPts) {
                // Sharper falloff to avoid "flying" dots
                let normX = pt.x / (baseSize / 2.3);
                let normY = pt.y / (baseSize / 2.3);
                let dSq = normX * normX + normY * normY;

                // Extremely sharp falloff to create a "solid ink stamp" boundary
                let rawProb = exp(-dSq * 6.5);

                let dynamicThreshold = pt.prob + noise(pt.x * 0.1, pt.y * 0.1, frameCount * 0.04) * 0.08 - 0.04;

                if (rawProb * densityMultiplier * flickerBase > dynamicThreshold) {
                    circle(cx + pt.x * scaleX, cy + pt.y * scaleY, pt.size);
                }
            }
        }

        function draw() {
            // Clear background with textured paper white
            background('#FDFDFD');

            // Draw the static paper noise underneath
            drawPaperNoise();

            // blendMode(MULTIPLY) produces the classic layered ink Risograph aesthetic
            // Wait, multiplying against #FDFDFD is fine, but it limits our colors if the dots are solid.
            // We will keep Multiply but use slight opacity in the fill for layering.
            // Actually, pure pointillism implies solid colors layered. Let's try pure colors with MULTIPLY.
            blendMode(MULTIPLY);

            noiseOffset += 0.02;

            let t = (frameCount % totalFrames) / totalFrames;

            let squeezeAmt = 0;
            let splitAmt = 0;
            let pipAmt = 0;

            // Sequence Map (One-shot, ends on final state):
            // 0.00 - 0.10: Coherent state (round ball)
            // 0.10 - 0.40: Orange pips appear on sides moving inward, squeezing ball horizontally
            // 0.40 - 0.70: The state splits out horizontally into Left and Right legs
            // 0.70 - 1.00: Hold Cat State (Ends here)

            if (t < 0.10) {
                pipAmt = 0;
                squeezeAmt = 0;
                splitAmt = 0;
            } else if (t < 0.40) {
                pipAmt = easeInOutCubic((t - 0.10) / 0.30);
                squeezeAmt = pipAmt;
                splitAmt = 0;
            } else if (t < 0.70) {
                pipAmt = 1.0;
                squeezeAmt = 1.0;
                splitAmt = easeInOutCubic((t - 0.40) / 0.30);
            } else {
                pipAmt = 1.0;
                squeezeAmt = 1.0;
                splitAmt = 1.0; // Hold at the split state eternally
            }

            // The "Pill" shape: highly squeezed X, stretched Y
            // Because we're splitting vertically, the ball should squeeze horizontally first
            let shapeSqueeze = squeezeAmt * (1.0 - splitAmt);

            push();
            translate(width / 2, height / 2);

            // Calculate scaling: vertically stretched, horizontally squeezed
            let scaleX = lerp(1.0, 0.2, shapeSqueeze);
            let scaleY = lerp(1.0, 2.8, shapeSqueeze);

            let offset = splitDistance * splitAmt;

            // --- Draw Orange Pips (The "Squeezers") ---
            // They push from Left and Right now to squeeze the ball into a vertical pill
            if (pipAmt > 0 && splitAmt < 1) {
                let currentPipScale = lerp(0.01, 0.40, pipAmt);
                let currentPipDist = lerp(120, 38, pipAmt);
                // Smooth fade out using inverted cubic easing on the split fraction
                let pipOpacity = lerp(0, 220, pipAmt) * (1.0 - easeInOutCubic(splitAmt));

                let pipAlpha = color(red(risoOrange), green(risoOrange), blue(risoOrange), pipOpacity);
                // Push from left and right
                drawRisoBlob(-currentPipDist, 0, currentPipScale * 0.7, currentPipScale * 1.5, 1.2, pipAlpha);
                drawRisoBlob(currentPipDist, 0, currentPipScale * 0.7, currentPipScale * 1.5, 1.2, pipAlpha);
            }

            // --- Draw Center Fringes (Interference Pattern) ---
            if (splitAmt > 0) {
                noStroke();

                let k = 0.40; // Tighter fringe spacing
                let timePhase = frameCount * -0.20;

                // Image 3 Rotated 90 Degrees.
                // The split is Top/Bottom (Y-axis).
                // The fringes run as VERTICAL STRIPES, meaning we modulate `x` in the cosine.
                // The overall envelope should be narrow vertically and stretched horizontally between the balls.

                // Blue Fringes
                fill(risoBlue);
                for (let pt of blueFringePts) {
                    let envXSq = (pt.x * pt.x) / (2 * 100 * 100); // spread horizontally
                    let envYSq = (pt.y * pt.y) / (2 * 45 * 45);  // narrow vertically
                    let env = exp(-envXSq - envYSq);

                    let wave = 0.5 + 0.5 * cos(pt.x * k + timePhase); // Vertical stripes!

                    let dynamicThresh = pt.prob + noise(pt.x * 0.1, pt.y * 0.1, frameCount * 0.1) * 0.1 - 0.05;
                    let prob = env * wave * splitAmt * 1.5;

                    if (prob > dynamicThresh) {
                        circle(pt.x, pt.y, pt.size);
                    }
                }

                // Orange Fringes
                fill(risoOrange);
                for (let pt of orangeFringePts) {
                    let envXSq = (pt.x * pt.x) / (2 * 100 * 100);
                    let envYSq = (pt.y * pt.y) / (2 * 45 * 45);
                    let env = exp(-envXSq - envYSq);

                    // Interlace phase shift by PI
                    let wave = 0.5 + 0.5 * cos(pt.x * k + Math.PI + timePhase);

                    let dynamicThresh = pt.prob + noise(pt.x * 0.1, pt.y * 0.1, frameCount * 0.1 + 100) * 0.1 - 0.05;
                    let prob = env * wave * splitAmt * 1.8;

                    if (prob > dynamicThresh) {
                        circle(pt.x, pt.y, pt.size);
                    }
                }
            }

            // --- Draw the Quantum State Lobes (Cat Legs) ---
            let baseAlpha = color(red(risoBlue), green(risoBlue), blue(risoBlue), 220);

            if (offset < 0.5) {
                drawRisoBlob(0, 0, scaleX, scaleY, 1.3, baseAlpha);
            } else {
                // Split Top and Bottom! (Vertical split 90 degrees rotated from image 3)
                drawRisoBlob(0, -offset, scaleX, scaleY, 1.1, baseAlpha);
                drawRisoBlob(0, offset, scaleX, scaleY, 1.1, baseAlpha);
            }

            pop();

            // Blend normal to render a subtle static paper noise across the whole screen continuously
            blendMode(BLEND);
        }

        // Static speckled paper noise
        let noisePts = null;
        function drawPaperNoise() {
            if (!noisePts) {
                noisePts = [];
                for (let i = 0; i < 25000; i++) {
                    noisePts.push({ x: random(width), y: random(height), size: random(1, 2) });
                }
            }
            fill(0, 0, 0, 15);
            noStroke();
            for (let pt of noisePts) {
                rect(pt.x, pt.y, pt.size, pt.size);
            }
        }
    </script>
</body>

</html>
